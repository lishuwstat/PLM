## one covariate with non-linear effect library(ICGOR)library(survival)library(ICsurv)library(pracma)library(MASS)library(splines)library(foreach)library(doParallel)library(doRNG)r = 0                   n <- 200                 # sample sizensimu <- 500             # number of replicatesbeta0 <- c(0.5,-0.5)     # true valuefun = 1                  # set up \Lambda=t/10,\phi=w^3+1#fun = 2                 # set up \Lambda=log(1+3/2*t),\phi=w^2-1tau = 8                  # the length of the study gt = 2                 order = 3                # degree of the monotone splines degree = 3               # degree of the B-splines n.lam <- 3               # Number of interior knots for the monotone splines  n.phi <- 3               # Number of interior knots for the B-splines sdata <- gen.data(n=n,fun=fun,r=r,gt=gt,tau=tau)            # generate dataw.seq <- seq(min(sdata$W)-1e-5 ,max(sdata$W),length.out=20) # obtain the estimate of phi() at these pointsti <- c(sdata$Li[sdata$d1 == 0], sdata$Ri[sdata$d3 == 0])t.seq <- seq(min(ti) -1e-5, 3, length.out = 30)             # obtain the estimate of Lambda() at these pointsBeta <- matrix(nrow=nsimu,ncol=length(beta0))Gama <- matrix(nrow=nsimu,ncol=n.lam+order)Lam0 <- matrix(nrow=nsimu,ncol=length(t.seq))                Phi0 <- matrix(nrow=nsimu,ncol=length(w.seq))               Lr <- Ir <- Rr <- matrix(nrow=nsimu,ncol=1)                 #left, interval and right censoring rates #####500 replicatesk <- 1flag = 0while(k <= nsimu){    sdata <- gen.data(n=n,fun=fun,r=r,gt=gt,tau=tau)    Rr[k] = mean(sdata$d3)  Ir[k] = mean(sdata$d2)  Lr[k] = mean(sdata$d1)    w.seq <- seq(min(sdata$W)-1e-5 ,max(sdata$W),length.out=20)    ti <- c(sdata$Li[sdata$d1 == 0], sdata$Ri[sdata$d3 == 0])  t.seq <- seq(min(ti) -1e-5, 3, length.out = 30)    em.fit <- try(Partial.Linear.PG(sdata, n.phi, n.lam, order=order, degree=degree, t.seq, w.seq ,max.iter=5000,cov.rate=.001),silent=TRUE)     if(!is.character(em.fit)){      Beta[k,] <- em.fit$b      Gama[k,] <- em.fit$g      Lam0[k,] <- em.fit$Lam          Phi0[k,] <- em.fit$psi.s        cat("EM finish\n")  }else{    cat(paste("EM Not Converge\n"))    flag = flag+1  }      cat(paste("simu=",k,"\n"))    print(Beta[k,])        k <- k+1  }##############bootstrap#################data <- array(cbind(sdata$W, sdata$X1, sdata$X2, sdata$Ti, sdata$Li, sdata$Ri, sdata$d1, sdata$d2, sdata$d3),c(n,9),dimnames=list(1:n, c("W", "X1", "X2","Ti","Li", "Ri","d1","d2","d3")))n.bs = 100Est1 <- matrix(nrow=n.bs,ncol=length(beta0))Std1 <- matrix(nrow=nsimu,ncol=length(beta0))Gama1 <- matrix(nrow=n.bs,ncol=n.lam+order)psi <- matrix(nrow=n.bs,ncol=20)Std.psi <- matrix(nrow=nsimu,ncol=20)lam <- matrix(nrow=n.bs,ncol=30)Std.lam <- matrix(nrow=nsimu,ncol=30)l <- 1while(l <= nsimu){    xxx <- foreach(bs=1:n.bs, .combine = cbind, .packages = c("survival","pracma", "doRNG"))%do%{        my.data <- data[sample(1:dim(data)[1], size=n,replace=TRUE),]          W  = my.data[ ,"W"]    X1 = my.data[ ,"X1"]    X2 = my.data[ ,"X2"]    Ti = my.data[ ,"Ti"]    Li = my.data[ ,"Li"]    Ri = my.data[ ,"Ri"]    d1 = my.data[ ,"d1"]    d2 = my.data[ ,"d2"]    d3 = my.data[ ,"d3"]    my.data <- data.frame(W=W,X1=X1,X2=X2,Ti=Ti,Li=Li,Ri=Ri,d1=d1,d2=d2,d3=d3)        w.seq <- seq(min(W)-1e-5 ,max(W),length.out=20)        tt <- c(Li[d1 == 0], Ri[d3 == 0])    t.seq <- seq(min(tt) -1e-5, 3, length.out = 30)    #the EM algorithm    em.fit <- try(Partial.Linear.PG(my.data, n.phi, n.lam, order=order, degree=degree, t.seq, w.seq ,max.iter=5000,cov.rate=.001),silent=TRUE)        #return estimates    if(!is.character(em.fit)){        Est1[bs,]  <- em.fit$b        cat("EM finish\n")    }else{      cat(paste("EM Not Converge\n"))    }        cat(paste("bs=",bs,"\n"))    print(Est1[bs,])        b_est <- Est1[bs,]        return( c(b_est) )  }    sd = apply(xxx,1,sd)  sd.b = sd[1:2]    cat(paste("nsimu=",l,"\n"))  Std1[l,] <- sd.b     l <- l+1}print(flag)  #print numbers of non-convergencebiasb = round((apply(Beta,2,mean) - beta0),3)sse.b = round((apply(Beta,2,sd)),3)see.b = round((apply(Std1,2,mean)),3)true<-matrix(beta0,ncol=length(beta0),nrow=nsimu,byrow=TRUE)  cp<-round(apply(((Beta-1.96*Std1)<true) & ((Beta+1.96*Std1)>true),2,mean),3) print(c('n=',n))print(c('r=',r))print(c('beta=',beta0))print(c('biasb=',biasb))print(c('sse.b=',sse.b))print(c('see.b=',see.b))print(c('cp=',cp))print(c('left=',mean(Lr)))print(c('right=',mean(Rr)))print(c('interval=',mean(Ir)))#################################Lf.median <- exp(-apply(Lam0,2,median))  Pf.median <- apply(Phi0,2,median) if(fun==1){  Lam.true <- function(t) exp(-t/10)  Phi.true <- function(w) w^3+1}if(fun==2){  Lam.true <- function(t) exp(-log(1+3/2*t))  Phi.true <- function(w) w^2-1}Lf.true <- Lam.true(t.seq)Pf.true <- Phi.true(w.seq)print(c(Lf.true[15],Lf.median[15]))print(c(Pf.true[10],Pf.median[10]))